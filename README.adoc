= Paneron plugin kit

== Plugin development

NOTE: Currently, only plugins released under `@riboseinc` NPM scope are supported.
Plugin name must be prefixed with `plugin-` (e.g., `plugin-foo-registry`).

=== Setup

. Create a new repository using Paneron plugin template repository (link to be added).

. Clone Paneron repository (link to be added) and build Paneron locally.

. Create a directory named `plugins-dev` somewhere on your machine.

==== Iteration

After you make changes:

. Rebuild the plugin from root directory.
+
[source,sh]
--
$ yarn build
--

. Copy _contents_ of `dist/` into `plugins-dev/@riboseinc/<your-plugin-NPM-package-name>`.

. Launch your local build of Paneron using a command like this:
+
[source,sh]
--
$ env PANERON_PLUGIN_DIR=/path/to/your/plugins-dev/directory yarn dev
--

==== Release

When ready, release NPM package and test on production Paneron build.

=== Rules of Paneron plugins

==== Depending on other modules

A plugin should not have any dependencies specified in package.json.
Anything you want to import should be provided by Paneron.

Here are modules you can import:

* "@blueprintjs/core"
* "@blueprintjs/datetime"
* "@blueprintjs/icons"
* "@blueprintjs/select"
* "@emotion/core"
* "@riboseinc/paneron-plugin-kit"
* "@riboseinc/paneron-registry-kit"
* "electron-log"
* "js-yaml"
* "react-window"
* "throttle-debounce"

==== Using React

A plugin cannot import React directly. Due to how resolving plugins at runtime works currently,
importing React in your components will cause two React instances to be running, which will break hooks.

Instead, your components will be passed a `react` prop.
Use that prop to invoke hooks and use fragments.

For example:

[source,tsx]
--
const MyRepositoryView: React.FC<RepositoryViewProps> = function ({ react, title }) {
  const [value, setValue] = react.useState(null);
  return <react.Fragment>Welcome to repository {title}!</react.Fragment>
}

This may change in future.
